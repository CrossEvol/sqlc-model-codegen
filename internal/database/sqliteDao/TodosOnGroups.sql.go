// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: TodosOnGroups.sql

package sqliteDao

import (
	"context"
	"database/sql"
	"strings"
)

const CountTodosOnGroups = `-- name: CountTodosOnGroups :one
SELECT count(*)
FROM TodosOnGroups
`

func (q *Queries) CountTodosOnGroups(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countTodosOnGroupsStmt, CountTodosOnGroups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateTodosOnGroup = `-- name: CreateTodosOnGroup :execresult
INSERT INTO TodosOnGroups (todo_id, group_id)
VALUES (?, ?)
`

type CreateTodosOnGroupParams struct {
	TodoID  int64 `db:"todo_id" json:"todo_id"`
	GroupID int64 `db:"group_id" json:"group_id"`
}

func (q *Queries) CreateTodosOnGroup(ctx context.Context, arg CreateTodosOnGroupParams) (sql.Result, error) {
	return q.exec(ctx, q.createTodosOnGroupStmt, CreateTodosOnGroup, arg.TodoID, arg.GroupID)
}

const DeleteTodosOnGroup = `-- name: DeleteTodosOnGroup :exec
DELETE
FROM TodosOnGroups
WHERE todo_id = ?
  and group_id = ?
`

type DeleteTodosOnGroupParams struct {
	TodoID  int64 `db:"todo_id" json:"todo_id"`
	GroupID int64 `db:"group_id" json:"group_id"`
}

func (q *Queries) DeleteTodosOnGroup(ctx context.Context, arg DeleteTodosOnGroupParams) error {
	_, err := q.exec(ctx, q.deleteTodosOnGroupStmt, DeleteTodosOnGroup, arg.TodoID, arg.GroupID)
	return err
}

const GetTodosOnGroupByGroupId = `-- name: GetTodosOnGroupByGroupId :one
SELECT todo_id, group_id, assigned_at
FROM TodosOnGroups
WHERE group_id = ?
LIMIT 1
`

func (q *Queries) GetTodosOnGroupByGroupId(ctx context.Context, groupID int64) (TodosOnGroup, error) {
	row := q.queryRow(ctx, q.getTodosOnGroupByGroupIdStmt, GetTodosOnGroupByGroupId, groupID)
	var i TodosOnGroup
	err := row.Scan(&i.TodoID, &i.GroupID, &i.AssignedAt)
	return i, err
}

const GetTodosOnGroupByTodoId = `-- name: GetTodosOnGroupByTodoId :one
SELECT todo_id, group_id, assigned_at
FROM TodosOnGroups
WHERE todo_id = ?
LIMIT 1
`

func (q *Queries) GetTodosOnGroupByTodoId(ctx context.Context, todoID int64) (TodosOnGroup, error) {
	row := q.queryRow(ctx, q.getTodosOnGroupByTodoIdStmt, GetTodosOnGroupByTodoId, todoID)
	var i TodosOnGroup
	err := row.Scan(&i.TodoID, &i.GroupID, &i.AssignedAt)
	return i, err
}

const GetTodosOnGroups = `-- name: GetTodosOnGroups :many
SELECT todo_id, group_id, assigned_at
FROM TodosOnGroups
`

func (q *Queries) GetTodosOnGroups(ctx context.Context) ([]TodosOnGroup, error) {
	rows, err := q.query(ctx, q.getTodosOnGroupsStmt, GetTodosOnGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TodosOnGroup
	for rows.Next() {
		var i TodosOnGroup
		if err := rows.Scan(&i.TodoID, &i.GroupID, &i.AssignedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTodosOnGroupsByGroupIds = `-- name: GetTodosOnGroupsByGroupIds :many
SELECT todo_id, group_id, assigned_at
FROM TodosOnGroups
WHERE group_id IN (/*SLICE:group_ids*/?)
`

func (q *Queries) GetTodosOnGroupsByGroupIds(ctx context.Context, groupIds []int64) ([]TodosOnGroup, error) {
	query := GetTodosOnGroupsByGroupIds
	var queryParams []interface{}
	if len(groupIds) > 0 {
		for _, v := range groupIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_ids*/?", strings.Repeat(",?", len(groupIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TodosOnGroup
	for rows.Next() {
		var i TodosOnGroup
		if err := rows.Scan(&i.TodoID, &i.GroupID, &i.AssignedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTodosOnGroupsByTodoIds = `-- name: GetTodosOnGroupsByTodoIds :many
SELECT todo_id, group_id, assigned_at
FROM TodosOnGroups
WHERE todo_id IN (/*SLICE:todo_ids*/?)
`

func (q *Queries) GetTodosOnGroupsByTodoIds(ctx context.Context, todoIds []int64) ([]TodosOnGroup, error) {
	query := GetTodosOnGroupsByTodoIds
	var queryParams []interface{}
	if len(todoIds) > 0 {
		for _, v := range todoIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:todo_ids*/?", strings.Repeat(",?", len(todoIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:todo_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TodosOnGroup
	for rows.Next() {
		var i TodosOnGroup
		if err := rows.Scan(&i.TodoID, &i.GroupID, &i.AssignedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
