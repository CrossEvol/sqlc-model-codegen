// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: Todo.sql

package sqliteDao

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const CountTodos = `-- name: CountTodos :one
SELECT count(*)
FROM Todo
`

func (q *Queries) CountTodos(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countTodosStmt, CountTodos)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateTodo = `-- name: CreateTodo :execresult
INSERT INTO Todo (title, score, amount, status, created_at, updated_at, deadline, priority, tags,
                    content, created_by, assignee_email, detail_id, category_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTodoParams struct {
	Title         string     `db:"title" json:"title"`
	Score         int64      `db:"score" json:"score"`
	Amount        float64    `db:"amount" json:"amount"`
	Status        string     `db:"status" json:"status"`
	CreatedAt     *time.Time `db:"created_at" json:"created_at"`
	UpdatedAt     *time.Time `db:"updated_at" json:"updated_at"`
	Deadline      *time.Time `db:"deadline" json:"deadline"`
	Priority      string     `db:"priority" json:"priority"`
	Tags          string     `db:"tags" json:"tags"`
	Content       string     `db:"content" json:"content"`
	CreatedBy     string     `db:"created_by" json:"created_by"`
	AssigneeEmail string     `db:"assignee_email" json:"assignee_email"`
	DetailID      *int64     `db:"detail_id" json:"detail_id"`
	CategoryID    *int64     `db:"category_id" json:"category_id"`
}

func (q *Queries) CreateTodo(ctx context.Context, arg CreateTodoParams) (sql.Result, error) {
	return q.exec(ctx, q.createTodoStmt, CreateTodo,
		arg.Title,
		arg.Score,
		arg.Amount,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Deadline,
		arg.Priority,
		arg.Tags,
		arg.Content,
		arg.CreatedBy,
		arg.AssigneeEmail,
		arg.DetailID,
		arg.CategoryID,
	)
}

const DeleteTodo = `-- name: DeleteTodo :exec
DELETE
FROM Todo
WHERE id = ?
`

func (q *Queries) DeleteTodo(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteTodoStmt, DeleteTodo, id)
	return err
}

const GetTodo = `-- name: GetTodo :one
SELECT id, title, score, amount, status, created_at, updated_at, deadline, priority, tags, content, created_by, assignee_email, detail_id, category_id
FROM Todo
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetTodo(ctx context.Context, id int64) (Todo, error) {
	row := q.queryRow(ctx, q.getTodoStmt, GetTodo, id)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Score,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deadline,
		&i.Priority,
		&i.Tags,
		&i.Content,
		&i.CreatedBy,
		&i.AssigneeEmail,
		&i.DetailID,
		&i.CategoryID,
	)
	return i, err
}

const GetTodos = `-- name: GetTodos :many
SELECT id, title, score, amount, status, created_at, updated_at, deadline, priority, tags, content, created_by, assignee_email, detail_id, category_id
FROM Todo
`

func (q *Queries) GetTodos(ctx context.Context) ([]Todo, error) {
	rows, err := q.query(ctx, q.getTodosStmt, GetTodos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Score,
			&i.Amount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deadline,
			&i.Priority,
			&i.Tags,
			&i.Content,
			&i.CreatedBy,
			&i.AssigneeEmail,
			&i.DetailID,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTodosByIds = `-- name: GetTodosByIds :many
SELECT id, title, score, amount, status, created_at, updated_at, deadline, priority, tags, content, created_by, assignee_email, detail_id, category_id
FROM Todo
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetTodosByIds(ctx context.Context, ids []int64) ([]Todo, error) {
	query := GetTodosByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Score,
			&i.Amount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deadline,
			&i.Priority,
			&i.Tags,
			&i.Content,
			&i.CreatedBy,
			&i.AssigneeEmail,
			&i.DetailID,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateTodo = `-- name: UpdateTodo :execresult
UPDATE Todo
SET title          = CASE WHEN ? IS NOT NULL THEN ? ELSE title END,
    score          = CASE WHEN ? IS NOT NULL THEN ? ELSE score END,
    amount         = CASE WHEN ? IS NOT NULL THEN ? ELSE amount END,
    status         = CASE WHEN ? IS NOT NULL THEN ? ELSE status END,
    created_at     = CASE WHEN ? IS NOT NULL THEN ? ELSE created_at END,
    updated_at     = CASE WHEN ? IS NOT NULL THEN ? ELSE updated_at END,
    deadline       = CASE WHEN ? IS NOT NULL THEN ? ELSE deadline END,
    priority       = CASE WHEN ? IS NOT NULL THEN ? ELSE priority END,
    tags           = CASE WHEN ? IS NOT NULL THEN ? ELSE tags END,
    content        = CASE WHEN ? IS NOT NULL THEN ? ELSE content END,
    created_by     = CASE WHEN ? IS NOT NULL THEN ? ELSE created_by END,
    assignee_email = CASE WHEN ? IS NOT NULL THEN ? ELSE assignee_email END,
    detail_id      = CASE WHEN ? IS NOT NULL THEN ? ELSE detail_id END,
    category_id    = CASE WHEN ? IS NOT NULL THEN ? ELSE category_id END
WHERE id = ?
`

type UpdateTodoParams struct {
	Title         interface{} `db:"title" json:"title"`
	Score         interface{} `db:"score" json:"score"`
	Amount        interface{} `db:"amount" json:"amount"`
	Status        interface{} `db:"status" json:"status"`
	CreatedAt     interface{} `db:"created_at" json:"created_at"`
	UpdatedAt     interface{} `db:"updated_at" json:"updated_at"`
	Deadline      interface{} `db:"deadline" json:"deadline"`
	Priority      interface{} `db:"priority" json:"priority"`
	Tags          interface{} `db:"tags" json:"tags"`
	Content       interface{} `db:"content" json:"content"`
	CreatedBy     interface{} `db:"created_by" json:"created_by"`
	AssigneeEmail interface{} `db:"assignee_email" json:"assignee_email"`
	DetailID      interface{} `db:"detail_id" json:"detail_id"`
	CategoryID    interface{} `db:"category_id" json:"category_id"`
	ID            int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateTodo(ctx context.Context, arg UpdateTodoParams) (sql.Result, error) {
	return q.exec(ctx, q.updateTodoStmt, UpdateTodo,
		arg.Title,
		arg.Score,
		arg.Amount,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Deadline,
		arg.Priority,
		arg.Tags,
		arg.Content,
		arg.CreatedBy,
		arg.AssigneeEmail,
		arg.DetailID,
		arg.CategoryID,
		arg.ID,
	)
}
